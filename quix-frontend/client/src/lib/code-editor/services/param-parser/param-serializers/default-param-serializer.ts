import {IParam, AUTO_PARAMS, TType} from '../param-types';
import {ParamSerializer, ITokenizedParam} from './param-serializer';

const EMBED_PREFIX = 'AUTOGENERATED';
const EMBED_SUFFIX = 'AUTOGENERATED END';

export class DefaultParamSerializer extends ParamSerializer {
  public *parse(text: string): Iterable<string[]> {
    const regex = new RegExp('\\$([a-z0-9_]+)(?:\\:([a-z_]+))?(?:\\:([^=]+))?=\\[([^\\[\\]]*)]|(\\$([a-z0-9_]+))|' + '(\\$((' + AUTO_PARAMS.join(')|(') + ')))', 'g');
    let param = null;

    // tslint:disable-next-line: no-conditional-assignment
    while ((param = regex.exec(text))) {
      yield param;
    }
  }

  public stringify(param: any[]): string {
    let pair = param;

    if (param.length > 1) {
      const value = param.pop();
      pair = [param.join(':'), `[${value}]`];
    }

    return pair.join('=');
  }

  public convert([match, key, type, options, value, keyOnlyParamMatch, keyOnlyParam, autoParamMatch, autoParamKey]: string[]): any[] {
    value = this.toJs(value, type as TType);
    options = (options && this.toJs(options, 'list')) || [];

    return [match, key, type, options, value, keyOnlyParamMatch, keyOnlyParam, autoParamMatch, autoParamKey];
  }

  public unconvert(param: any[]): string[] {
    return param;
  }

  public transform(param: ITokenizedParam): ITokenizedParam {
    return param;
  }

  public untransform(param: ITokenizedParam): ITokenizedParam {
    return param;
  }

  public tokenize([match, key, type, options, value, keyOnlyParamMatch, keyOnlyParam, autoParamMatch, autoParamKey]: any[]): ITokenizedParam {
    let isAutoParam = false;
    let isKeyOnlyParam = false;

    if (autoParamMatch) {
      match = autoParamMatch;
      key = autoParamKey;
      isAutoParam = true;
    } else if (keyOnlyParamMatch) {
      match = keyOnlyParamMatch;
      key = keyOnlyParam;
      isKeyOnlyParam = true;
    }

    return {match, key, value, type, isAutoParam, isKeyOnlyParam, options};
  }

  public detokenize({key, type, value, isAutoParam, isKeyOnlyParam, options}: ITokenizedParam, serializationType: 'serialize' | 'value'): string[] {
    const res = [];

    switch (serializationType) {
      case 'serialize':
        res.push(`$${key}`);

        if (!isAutoParam && !isKeyOnlyParam) {
          res.push(type);

          if (options && options.length) {
            res.push(options);
          }

          res.push(value);
        }

        break;
      case 'value':
        res.push(value);
        break;
      default:
    }

    return res;
  }

  public embed(text: string, params: IParam[]): string {
    const paramsText = params.map(param => this.serialize(param as ITokenizedParam)).join(' ');

    return `/* ${EMBED_PREFIX}\n${paramsText}\n${EMBED_SUFFIX} */\n`;
  }

  public extract(text: string): string {
    const match = new RegExp(`^\\/\\*[\\s\\S]+${EMBED_PREFIX}[\\s\\S]+${EMBED_SUFFIX}[\\s\\S]+?\\*\\/\\n?`).exec(text);

    return (match && match[0]) || '';
  }

  public getLockRange(text: string): [number, number][] {
    return [[0, this.extract(text).split('\n').length - 2]];
  }

  public toJs(value: string, type: TType = 'string'): any {
    if (typeof value === 'undefined') {
      return null;
    } 
    
    if (type === 'boolean') {
      return value === 'true' ? true : false;
    } 
    
    if (type === 'number') {
      return parseInt(value, 10);
    } 
  
    if (type === 'list') {
      return value.split(',');
    } 
    
    return value;
  }

  public toString(value: any, type: TType = 'string'): any {
    // tslint:disable-next-line: restrict-plus-operands
    return '' + value;
  }
}

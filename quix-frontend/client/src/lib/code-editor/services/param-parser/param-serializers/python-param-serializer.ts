import {isArray, isPlainObject, assign} from 'lodash';
import {IParam, AUTO_PARAMS, TType} from '../param-types';
import {ParamSerializer, ITokenizedParam} from './param-serializer';

const EMBED_PREFIX = '# AUTOGENERATED {';
const EMBED_SUFFIX = '# AUTOGENERATED END }';
const CUSTOM_FN_DEF = 'def __custom__():';
const CUSTOM_FN_CALL = '__custom__()';
const INIT_FN_DEF = 'def __init__(c):';
const INIT_FN_CALL = '__init__(False)';
const CUSTOM_REGEX = `(${CUSTOM_FN_DEF.replace(/(\(|\))/g, '\\$1')})([\\s\\S]+)(${INIT_FN_DEF.replace(/(\(|\))/g, '\\$1')})`;
const EMBED_REGEX = `^${EMBED_PREFIX}[\\s\\S]+${EMBED_SUFFIX}\\n`;
const PARAM_REGEX = `\\((?:"([a-zA-Z0-9_]+)","([a-z]+)",(.+?),(\\[.*?\\]))\\)|(\\("(${AUTO_PARAMS.join('|')})",None,(?:(?:"\\$[a-zA-Z_]+")|None),\\[[^\\[\\]]*\\]\\))`;
const PARAMS_VAR = 'p';

const PYTHON_TO_JS = {
  None: null,
  True: true,
  False: false
};

const PYTHON_TO_JS_BY_TYPE = {
  list: {
    '\\(': '[',
    '\\)': ']'
  }
};

const JS_TO_PYTHON = {
  null: 'None',
  true: 'True',
  false: 'False'
};

const JS_TO_PYTHON_BY_TYPE = {
  list: {
    '\\[': '(',
    '\\]': ')'
  }
};

function transform(value, transformations) {
  return Object.keys(transformations).reduce((res, k) => res.replace(new RegExp(`(${k})`, 'g'), transformations[k]), value);
}

function getSerializedParamsText(serializedParams: string[]) {
  return `${PARAMS_VAR} = [${serializedParams}]`;
}

function getEmbedText(params: IParam[], serializedParams: any[]): string {
  return `${EMBED_PREFIX}
def __param__(key, options, value = None):
    _fields('k', 'o', 'v')
    _row(key, options, value)
${CUSTOM_FN_DEF}

    pass
${INIT_FN_DEF}
    ${getSerializedParamsText(serializedParams)}
    if c:
        ${CUSTOM_FN_CALL}
    return {t[0]: t[2] for t in ${PARAMS_VAR}}
q = ${INIT_FN_CALL}
${EMBED_SUFFIX}
`;
}

export class PythonParamSerializer extends ParamSerializer {
  public *parse(text: string): Iterable<string[]> {
    const regex = new RegExp(PARAM_REGEX, 'g');
    let param = null;

    // tslint:disable-next-line: no-conditional-assignment
    while ((param = regex.exec(this.extract(text)))) {
      yield param;
    }
  }

  public stringify(param: any[]): string {
    return `(${param})`;
  }

  public convert([match, key, type, value, options, autoParamMatch, autoParamKey]: string[]): any[] {
    value = this.toJs(value, type as TType);
    options = (options && this.toJs(options, 'list')) || [];

    return [match, key, type, value, options, autoParamMatch, autoParamKey];
  }

  public unconvert(param: any[], type: TType): string[] {
    return param.map(p => this.toString(p, type));
  }

  public tokenize([match, key, type, value, options, autoParamMatch, autoParamKey]: any[]): ITokenizedParam {
    let isAutoParam = false;
    const isKeyOnlyParam = false;

    if (autoParamMatch) {
      match = autoParamMatch;
      key = autoParamKey;
      isAutoParam = true;
    }

    return {match, key, value, type, isAutoParam, isKeyOnlyParam, options};
  }

  public detokenize({key, type, value, isAutoParam, options}: ITokenizedParam, serializationType: 'serialize' | 'value' = 'serialize'): any[] {
    let res;

    switch (serializationType) {
      case 'serialize':
        if (isAutoParam) {
          res = [key, null, `$${key}`, []];
        } else {
          res = [key, type, value, options];
        }
        break;
      case 'value':
        res = [key, null, value, null];
        break;
      default:
    }

    return res;
  }

  public transform(param: ITokenizedParam): ITokenizedParam {
    return param;
  }

  public untransform(param: ITokenizedParam): ITokenizedParam {
    return param;
  }

  public embed(text: string, params: IParam[]): string {
    let res = getEmbedText(params, params.map(param => this.serialize(param as ITokenizedParam)));
    const custom = new RegExp(CUSTOM_REGEX).exec(text);

    if (custom) {
      res = res.replace(new RegExp(CUSTOM_REGEX), `$1${custom[2]}$3`);
    }

    return res;
  }

  public extract(text: string, options = {runCustom: false}): string {
    const match = new RegExp(EMBED_REGEX).exec(text);
    let res = '';

    if (!match) {
      return res;
    }

    res = match[0];

    if (options.runCustom) {
      res = res.replace(INIT_FN_CALL, INIT_FN_CALL.replace(this.toString(false), this.toString(true)));
    }

    return res;
  }

  public getLockRange(text: string): [number, number][] {
    const range = [];
    const rows = this.extract(text).split('\n');

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];

      if (row.includes(CUSTOM_FN_DEF)) {
        range.push([0, i]);
      } else if (row.includes(INIT_FN_DEF)) {
        range.push([i, rows.length - 2]);
        break;
      }
    }

    return range;
  }

  public toJs(value: string, type: TType): any {
    if (!value) {
      return value;
    }

    value = transform(value, assign({}, PYTHON_TO_JS, PYTHON_TO_JS_BY_TYPE[type]));

    return type === 'string' ? value.replace(/^"/, '').replace(/"$/, '') : JSON.parse(value);
  }

  public toString(value: any, type: TType = 'string'): string {
    if ((typeof value === 'boolean' || value === null) && typeof JS_TO_PYTHON[value] !== 'undefined') {
      return JS_TO_PYTHON[value];
    } 
    
    if (isArray(value)) {
      return `[${value.map(v => transform(this.toString(v), JS_TO_PYTHON_BY_TYPE.list))}]`;
    } 
    
    if (isPlainObject(value)) {
      return `{${Object.keys(value).map(k => `"${k}":${this.toString(value[k])}`).join(',')}}`;
    } 
    
    if (typeof value === 'string' && value.length) {
      if (JS_TO_PYTHON_BY_TYPE[type]) {
        value = transform(value, JS_TO_PYTHON_BY_TYPE[type]);
      }

      return JSON.stringify(value);
    } 
    
    if (typeof value === 'number') {
      // tslint:disable-next-line: restrict-plus-operands
      return '' + value;
    }

    return 'None';
  }
}
